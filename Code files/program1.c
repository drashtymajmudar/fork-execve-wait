/* Write a shell that is similar to Fig. 1-19 but contains enough code that it actually works
so you can test it. You might also add some features such as redirection of input and
output, pipes, and background jobs. */


#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>


int main (int argc, char *argv[], char *envp[])

{
	int pid1,pid2,result,status;
	int flag=1;
	char *arg[] ={argv[1],argv[2],NULL};  /* arg is input parameter for execve call. arg[0]=name of executable, arg[1]=path of file to be read by executable, Null parameter at the end is mandatory */
	
	if(argc<3)  //minimum number of command line arguments is 3.
	{
		printf("Insufficient command-line arguments. \n");
		return 0;
	}
	
        
	while (flag==1)   // flag variable controls whether the program has to be continued or terminated
	{
		
		pid1=getpid();   // get PID of current process (parent)
		result=fork();   //create child process
	
		if(result<0)     //if result is negative, then the process creation failed 
		{
			printf("Failed to create child process.");
		}
		else
		{
			pid2=getpid();    //get PID of child process
			if(result==0)     //if result is 0, then the child process code is executed
			{
				printf("Process %d spawned by process %d. \n",pid2,pid1);
				printf("Process %d reading file %s \n", pid2,argv[2]);
				execve(arg[0],arg,NULL);	// execute the code in file_read.c
			}
			else //if result is positive, it is PID of child process and the parent process code is executed
			{
				printf("Parent Process %d \n", pid1);  
				waitpid(-1,&status,0);	// wait for child process to finish
				printf("Process %d finished work \n", result);	
				printf("Process %d Waited for %d. \n",pid1,result);
			}
			
		}
		
		printf("\n To continue, press 1. To exit, press any numeric key \n");
		scanf("%d",&flag);
		if(flag!=1)
		{
			exit(0);
			return 0;
		}
		
	}
	
	
}
